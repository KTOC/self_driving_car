***8주차 2일짜 20190702 수업***

***20190702 마지막업데이트***

# Week 8 - Day 2 - 자율주행 기능구현을 위한 차량용 SW개발

<!-- 
![001](./book/자율주행기능구현을위한차량용SW개발2_페이지_001.jpg)
![002](./book/자율주행기능구현을위한차량용SW개발2_페이지_002.jpg)
![003](./book/자율주행기능구현을위한차량용SW개발2_페이지_003.jpg)
![004](./book/자율주행기능구현을위한차량용SW개발2_페이지_004.jpg)
![005](./book/자율주행기능구현을위한차량용SW개발2_페이지_005.jpg)
![006](./book/자율주행기능구현을위한차량용SW개발2_페이지_006.jpg)
![007](./book/자율주행기능구현을위한차량용SW개발2_페이지_007.jpg)
![008](./book/자율주행기능구현을위한차량용SW개발2_페이지_008.jpg)
![009](./book/자율주행기능구현을위한차량용SW개발2_페이지_009.jpg)
![010](./book/자율주행기능구현을위한차량용SW개발2_페이지_010.jpg)
![011](./book/자율주행기능구현을위한차량용SW개발2_페이지_011.jpg)
![012](./book/자율주행기능구현을위한차량용SW개발2_페이지_012.jpg)
![013](./book/자율주행기능구현을위한차량용SW개발2_페이지_013.jpg)
![014](./book/자율주행기능구현을위한차량용SW개발2_페이지_014.jpg)
![015](./book/자율주행기능구현을위한차량용SW개발2_페이지_015.jpg)
![016](./book/자율주행기능구현을위한차량용SW개발2_페이지_016.jpg)
![017](./book/자율주행기능구현을위한차량용SW개발2_페이지_017.jpg)
![018](./book/자율주행기능구현을위한차량용SW개발2_페이지_018.jpg)
![019](./book/자율주행기능구현을위한차량용SW개발2_페이지_019.jpg)
![020](./book/자율주행기능구현을위한차량용SW개발2_페이지_020.jpg)
![021](./book/자율주행기능구현을위한차량용SW개발2_페이지_021.jpg)
![022](./book/자율주행기능구현을위한차량용SW개발2_페이지_022.jpg)
![023](./book/자율주행기능구현을위한차량용SW개발2_페이지_023.jpg)
![024](./book/자율주행기능구현을위한차량용SW개발2_페이지_024.jpg)
![025](./book/자율주행기능구현을위한차량용SW개발2_페이지_025.jpg)
![026](./book/자율주행기능구현을위한차량용SW개발2_페이지_026.jpg)
![027](./book/자율주행기능구현을위한차량용SW개발2_페이지_027.jpg)
![028](./book/자율주행기능구현을위한차량용SW개발2_페이지_028.jpg)
![029](./book/자율주행기능구현을위한차량용SW개발2_페이지_029.jpg)
![030](./book/자율주행기능구현을위한차량용SW개발2_페이지_030.jpg)
![031](./book/자율주행기능구현을위한차량용SW개발2_페이지_031.jpg)
![032](./book/자율주행기능구현을위한차량용SW개발2_페이지_032.jpg)
![033](./book/자율주행기능구현을위한차량용SW개발2_페이지_033.jpg)
![034](./book/자율주행기능구현을위한차량용SW개발2_페이지_034.jpg)
![035](./book/자율주행기능구현을위한차량용SW개발2_페이지_035.jpg)
![036](./book/자율주행기능구현을위한차량용SW개발2_페이지_036.jpg)
![037](./book/자율주행기능구현을위한차량용SW개발2_페이지_037.jpg)
![038](./book/자율주행기능구현을위한차량용SW개발2_페이지_038.jpg)
![039](./book/자율주행기능구현을위한차량용SW개발2_페이지_039.jpg)
![040](./book/자율주행기능구현을위한차량용SW개발2_페이지_040.jpg)
![041](./book/자율주행기능구현을위한차량용SW개발2_페이지_041.jpg)

여기까지1장 -->


2.1 Software build process
2.2 Preprocess
2.3 Compile
2.4 Assemble
2.5 Link
2.6 Load
2.7 Debug
2.8 Tool chain, cross tool chain

3. Software development environment
3.1 about AURIX
3.2 Install !DE
3.3 Environment test

4. C overview
4.1 C overview
4.2 C data types
4.3 C operators

5. C programming
5.1 Array
5.2 Pointer
5.3 Function

6. Assembly language
6.1 Assembly language overview
6.2 TriCore assembly language

7. Machine language
7.1 Machine language overview
7.2 TriCore machine language

8. Device control in C
8.1 Device control overview
8.2 Bitwise operators
8.3 Cast operators
8.4 Address-of and indirection operators
8.5 union : struct : bit-field

9. Device control(1/2)
9.1 1/0 practice
9.2 Interrupt practice

9. Device control(2/2)
9.3 Timer practice
9.4 ADC practice
9.5 PWM practice


---
## CH02 Software build system



![042](./book/자율주행기능구현을위한차량용SW개발2_페이지_042.jpg)

### Software build process


일단 빌드를 하면 뭔가 만들어내는데 컴퓨터가 동장시킬 수 있는 어떤 것을 만들어낸다. 결국은 더하기 빼기, 로드/스토어

* 정적인것 실행중에 바꾸지 않는다. 안정적.
* 동적인 것은 동적으로 컴파일, 상황에 따라, 그렇게 되는 형태 있고 한번 명령 고정하면 안 바뀌는 언어들.

정적인게 메모리 효율도 좋다.

![043](./book/자율주행기능구현을위한차량용SW개발2_페이지_043.jpg)

어셈블, 디스어셈블.

MCU 전원이 들어가면 자기 부트 시퀀스가 있다. 0번지에 수행한다거나 정해진 주소가 있다. 그 주소에 들어가서 .. 결국 스타트코드를 부트시퀀스에 일치하게 다운로드 해놔야 한다 그게 들어가면 하나씩 실행하게 된다. 

명령어는 위에서 아래로 내려가는 반복하는.. 

테스트는 유닛테스트한다 할때 다운로드 시켜서 테스트 할 때 어떤식으로 가냐하면 어떤 테스트케이스 방법여러개 있다. 함수 아웃풋 있다. 인풋 벨류, 테스트벨류 만들어서 넣는다. 엑츄철벨류, 익스펙티드 벨류 셋팅값과 컴페어한다. 값일치하면 페스, 그 테스트케이스에 대해서는 정상적으로 동작했다 그런데 값이 일치하지 않으면 fail 그걸 리포팅 해준다. 그런 fail 리포트 같은 것 보고 개발자가 고쳐야 한다. 그런 반복이다. 오래걸린다. 도구 숙달. 그러려면 시간투자 필요하다. 소프트웨어 시간투자 꼭. 메뉴얼 다 읽어야 한다. 본인이 사용하는게 남들이 많이 안쓰면 그게 골때리는 거다. 

메뉴얼, 내용, 순서 비슷하다. 한가지만 익혀주면 다른 것을 습득하는데 소모시간 많이 줄어든다.

### Preprocess

![045](./book/자율주행기능구현을위한차량용SW개발2_페이지_045.jpg)

목적 알고 있어야.. 전처리 뭘 전처리? 변화? 뭘 변환? 치환? 메크로? 지우는 역할 한다. 복사, include 복사 개념이다. if endif 조건부 컴파일 지시어, 조건부로 뭔가 걸렸을때 트루면 유지시키는데 false는 지워주는, 단순화, text editing변경일 주로 일어난다. 왜 하냐? 프로그램 만들기 편하라고, 이거 없어도 실제 기계어 만드는데 영향 안준다. 근데 가독성 높여준다. 긴 문장 쓰려면 프로그램 불편한다. 

`*0x1000A000`
```c
#define A (*(volatail unsignd int *)0x1000A000) = 10;
A=10;
```

제대로 이해하고 있으면 굉장히 편해지는 `type definition` 필수

* `#if 1` 조건부컴파일
* `#pragma` 잘 쓸 줄 알아야 한다.

제어쪽 2메가 램 1메가도 안되기에 아껴서 써야한다. 아꼈는데 느리면 또 안된다. 10+5했는데 10초 걸리면 안되니까. 만들기에 따라 다르다. 최적화. 최적화 신경써야하는데 그때 사용하는 전처리 지시어이다. `최적화` 목적 2개. 

* 메모리 효율 향상
* 퍼포먼스 향상
  * size and speed trade off 관계

예를들어 룩업테이블, 연산량 많으니까 인덱싱 미리 올려놓고 최적화, 연산속도 많은 , 컴파일러가 미리 최적화

최적화의 단위가 있다. `scope` 최소단위 저걸 안쓰면 `file scope` 제일 작은 단위가 .c 

상황에 따라서 함수최적화 그게 안된다. 얘가 없으면. `pragma`

변수, 함수 원하는 위치로 옮겨놓을 수 있다. 스켓터 로딩. 이때 `pragma` 같은 것을 활용한다. 

![046](./book/자율주행기능구현을위한차량용SW개발2_페이지_046.jpg)

### Compile

gcc 옵션 `save temps` 남는다. 

![047](./book/자율주행기능구현을위한차량용SW개발2_페이지_047.jpg)

메인함수 컴파일하면 어셈블리로 바뀐다. 기계어 되기 전 단계. 이때 일어나는 일이 중간에 만들어진 전처리 끝난 문법의 형태가 아직 C 언어. 안에 내부 씨, 명령어(어셈블리), 전역변수 변수영역 bss data 

지역변수 스텍, 운영 명령어 이때 최적화, 명령어 갯수, 어떤 명령어를 쓸지 메모리 사용량, 속도 이 단계에서 최적화 옵션 적용 

![048](./book/자율주행기능구현을위한차량용SW개발2_페이지_048.jpg)

### Assemble

전처리가 끝난 c언어 문법 어셈블로 바꿔진 경우.

컴파일되면 어셈블 단계

어셈블 작업 인코딩, 기게가 이해할 수 있는 형태로 변환. 그대 만들어진 것들. 오브젝트 코드


![049](./book/자율주행기능구현을위한차량용SW개발2_페이지_049.jpg)

위에는 리로케이터블 asw.s 에서 bsw.s 로 함수호출하려고 할 때 정보 모른다. 이름만 안다. 시그니처들, 리턴, 파라메터만 안다. 그래서 어느 메모리에 있는지 모른다. 어디에 다운로드 될지. 그래서 비워놓는다. 영역을. 빈공간으로 해놓고 링커가 해준다. 링커 안쓰면 직접 다 해줘야한다. 그 작업들 엄청 많다. 다운로드 각각 해줄수 있다 쳐도 링크 힘들다. 참조? 알아서 하면 된다. 어떻게 돌아가는지 알면. 그래서 링커 단계로 가서 메모리 어디서 올릴지 링크


오브젝트 코드 이걸 가지고 정적라이브러리, 어걸 가지고 실행파일 등 다 만들 수 있다. 소스코드  하나당 하나의 오브젝트 코드들이 생성 가ㅡ능. 읽어봤자 소용이 ..없다. 

오브젝트 파일 포멧 자체를 알고 있으면 데이터 추출, 뽑아서 쓸수 있다. 다이텍츠 파일 자체 읽는건 힘들다. 

elf 맨 앞에 매직넘버 1개 있다. 이런 것

아키텍쳐, 엔트리포인터 어떤 주소. elf 엑시큐트, 리로케이션 형태, fpu ㅇ떤 형태인지 ㅂㅓ전 몇인지 굿베드엔디언은 어느오


![050](./book/자율주행기능구현을위한차량용SW개발2_페이지_050.jpg)

### Link

링크단계, 합치기
기계어까지 어셈블까지 바이너리 잘 꺼내서 실행하면 잘 된다. 

s/d RAM NOR -F EER
* 바이트 엑세스 접근해야 이런 종류가 가능하다.
* 이런 종류의 데이터를 써야하고 바이트마다 주소가 다 있다.
* 주소가 있단ㄴ 말이 바이트 접속 가능하다는.

롬, 렘 바이트 엑세스 가능한 

memory 0x00 주소 가 있다고 했을 때 주소를 알아서 지정해야한다. 

![051](./book/자율주행기능구현을위한차량용SW개발2_페이지_051.jpg)

링커는 정보가 엄청 많다. 런타임, 어느메모리로, 카피 어디서 어디로 정보들을 다 제공해야한다. 그래서 컴파일러 제조사에서 스크립트 문법으로제공한다. 파일에다가 메모리 레이아웃 기술 사용하게끔, 링커 스크립트 랭기지, 파일 그 안에 배치, 많은 정보들을 제공해주게 된다. 정보 양이 굉장히 많다. 

전역변수, 컨스탄트, 카피 어느번지에서 어느 번지로, 이건 진짜 실행파일. 리로케이트, 위치 잡아주는

![052](./book/자율주행기능구현을위한차량용SW개발2_페이지_052.jpg)

링커스크립트 언어 쉬운데 하드웨어 기반지식 필요하다. 어려운것은 아니다. 컨셉만 이해하자. 링커스크립트는 컴파일러마다 다 다르다. gcc 는 ld (링커이름) 문법공부하면 좋은게 다 gcc 쓴다. 리눅스는 다 gcc 파생된 것들. 그럼 한번만 공부하면 다 좋다. 시스템할때. 물리메모리 어떻게 할 지

코드워리어 같은 언더 또 다드라. 오릭스 슬 때 타스킹 tasking 문법 다르다. 이런 단어 자체가 다 다르다. 

링커 공부할 때는 `VMA` `LMA` 중요하다 

코어관련한건 모두 버추얼, 코어가 볼때 Virtual. MMU 물리메모리랑 장치 사이 껴 들어가는데 메모리 맵핑 하는데 운영하는, 관리하는, 그냥 용어가 그렇다 코어입장에서 보는 모든 어드레스가 됐건 다른 장치들 다 Virtual이라고 보고 이해하면 된다. Virtual, 피지컬 어드레스 매팡하는게 MMU. 메모리 읽었을때 Virtual. 실행. 코어. 러닝. 러닝하는 주소다. 코어가 접근하는 주소를 Virtual adress, 피지컬 어드레스랑 다를 수 있다. 작은 MCU는 MMU가 없다 그래서 1:1로 맵핑 Virtual 0번지는 피지컬하고 0번지 거의. 살짝 틀어질 수도 있으니 확인. 어쨌든 Virtual은 실행 어드레스..

LMA • Load Memory Addr는 로드어드레스

ROM RAM  램에는 VMA 로드메모리는 ROM에 이런 정보들을 잘 써야 어쨌든 이런 정보들이 핵심이다. 

![053](./book/자율주행기능구현을위한차량용SW개발2_페이지_053.jpg)



. ld
```
SECTIONS
{
    . BMD HDR_CONST_FAR_UNSPECIFIED
    {
    KEEP( *(. r odata.BMD_HDR_CONST_FAR_UNSPECIFIED))
    } > PMU_PFLASH0_BMI

    . startup :
    {
    KEEP (*( . startup_code))
    = ALIGN(S);
    } > PMU_STARTUP

    .CPU0 PRIVATE_CODE
    {
    PROVIDE(_CPU0_PRIVATE_CODE_start = .);
    KEEP( *(.text.CPU0.Private*))
    PROVIDE(_CPU0_PRIVATE_CODE_end .);
    } > PMU_PFLASH0
}
```
gcc 에서의 메모리 설정. 명 변경. 

`.` 커런트 어드레스, 현재주소.


    PROVIDE(_CPU0_PRIVATE_CODE_start = .);
시작주소 설정하고.
    KEEP( *(.text.CPU0.Private*))
100바이트짜리 내용 쌓고
    PROVIDE(_CPU0_PRIVATE_CODE_end .);
끝주소 로 end 주소 설정

`aligned access` 레지스터의 크기에 맞춰 메모리를 저장하고 엑세스 하는 것이다

`un-aligned access`
```
.text.Ube . reset ( 2783 )
.text . inttabe . intvec .001 ( 1981)
.text. inttabe. intvec. 003 ( 1994)
.text. inttabe. i nt vec. 005 ( 5 )
.text . inttabe.intvec .006 ( 7)
.rodata .Mc a l _Trap .. 1 . str (2240)
.rodata .Mcal_Trap .. 10 .st r (2249)
.rodata .Mcal_Trap . . 11.str (2250)
.rodata .Mc a l Trap . . 12.str ( 2251)
.data.DEFAULT RAM_32BIT IIONZERO_IIIIT ( 2945)
.data.DEFAULT RA.'1_32B1T_NONZERO_INIT ( 2946)
.data. DEFAULT _RAM_32BIT tO~ZERO_rnIT ( 2947)
.data. DEFAULT _RA11_32BIT _NONZERO_INIT ( 2948 )
.data. Shared .OE FAUL T_ RAl1_ INIT_32BIT ( 3061)

이 아래는 지워지는  
.bs~. Share-d .OEFAUL T _RAl-,_328IT (2239)
.bss.Shared.OfFAULT_RA.'1_utfSPECIFIED (310)
.bss. _dbg_request.libcs_fpu (3529) 
.bs,:s. Shared .DEFAUL T_fW1_8BIT (1738)
```



rodata 초기값 0이 아니다. data 도 초기값이 0이 아니다?

런타임에 0을 쓴다? 링커가? 어셈블리 밖에 못한다. c 언어 들어가기 전에 해줘야 한다. 


* text
* data 정적
* heap
* stack 동적

c 언어로 많이 스니까 heap은 안쓴다. 위험해서. stack도 잘 서야한다. 오버플로우 문제점, 동적, 잘 써야한다. 정적, 고정 안 바뀌는 초기값 


elf 포멧, 구조체 형태, 매직넘버.

바이너리들, bss 없고 바이너리. 있고 주소멤핑테이블, 심볼네임들, elf 묶여서 패키징 이거 없으면 디버깅 못한다. 할 수 있는데 굉장히 어렵다. 메인함수에 몇번지에 있는지.. ADA 써서 해킹? 어셈블릴로 구조 콜 쉽게 뽑아주는.

링크 긑나면 elf 나오고 바이너리 뽑아서 다운로드, elf 뽑아서 다운로드 그건 각 다르고

### Load

정적인 영역, 



### Debug
### Tool chain, cross tool chain


.text
.data
heap
stack

로드스토어 로드스토어 4바이트 통짜로
bss.는 레지스터0셋팅 한후 그 값을 주소에다가 스토어스토어스토어
명령어 다운롣드 안해놌는 이유. 로드 1번 스토어 1번
bss 한번 한번 한번 이 효과가 엄청 나다. 
성능최적화 메모리 접근을 없애버린다. 코어스피드랑 메모리 스피드 차이 많이 난다. 메모리 최소한 접근하게 하면 성능 좋다. 
그래서 리스크 머신은 

부트로더. 버그 생겨서 업뎃해줘야할때 이씨유에 디버거 포트있으면 해킹있으니까 그냥 끊어버린다. 안나와있다. 양산 자체가. 그래서 버스. 부트로더 쪽에 지원되는 통신방법 적용되 방

디버거 이용하지 않으면 메모리 다이렉트 다른 방법으로 접근해야한다.

소타포타? 
소프트웨어 오버디에어?
FOTA 
SOTA 지금 쓰고 있는 기술, 스마트폰 같은.

클릭하면 알아서어야

차 운전하는데 업데이트 까지 같이 할 수 있어야한다. 용량 많으니까. 그런데 운전중에 잘못될 수 있으니까. ROM 많이 이써야 한다. 이런 식으로 만들어서 쓴다.


FOTA 업데이트 시ㅈ
사용자가 업데이트하시겠습니까? 설치하시겠습니까 누르면 스왑
제일 좋은 기술

BINROM 에 써놓고 끊어놓고 버스체인지

8M 짜리면 16메가로 늘어나고 오릭스 있다. 2세대 오릭스에 들어간다. 

![054](./book/자율주행기능구현을위한차량용SW개발2_페이지_054.jpg)

![055](./book/자율주행기능구현을위한차량용SW개발2_페이지_055.jpg)
![056](./book/자율주행기능구현을위한차량용SW개발2_페이지_056.jpg)

![057](./book/자율주행기능구현을위한차량용SW개발2_페이지_057.jpg)

---

# 실습

받은 파일 2개

T32 
* 디버거 로우레벨 분석가능
TASKING_TriCore-VX_v4.3r3
* 컴파일러 2천만원

라이센스가 플로팅 라이센스, 서버와 연결해야 끝난다.

시스템/계정 환경변수 새로만들기로 추가
* 변수이름: LM_LICENSE_FILE
* 변수값: 7594@192.168.101.26

* C:\Workspace_AURIX
* 워크벤치

a.b.c. 스텝 버그 있을 수 있기에

디버거 전원 먼저 타겟 전원 다음

제거할 때는 

타겟 그 다음 디버거

뎁? 데비? 연결할 거다

10핀짜리 1과 빨간선을 맞춰라. 연결

그 다음에 C드라이브 T32 실행파일은 bin 안에.

`C:\T32\bin\windows\t32mtc.exe`

tc가 프로세서 이름, 암 같은 경우 t32marm

* c드라이브 새폴더 만드로 Temp 만들어 놓으면 오류 안난다.
* 잘 해결되면 welcome windows 나온다.


power down, 타겟의 전원이 안들어와 있다.
system down 연결 완료

이제 이 mcu의 셋팅 필요

포트 램 한 포트밖에 없어서 경로가 1개다. 그런데 CPU 2개를 달고 램놓고 두 데이터 공유하고 싶을 때 렘 달고 그걸  하기 힘들다 포트 1개 밖에 ㅇ벗어서. 그래서 포트2개 경로2개, 2개를 연결시켜서 공유할 수 있다 데이터를.

디버깅 jtag 기반 디버깅이다. 인베이시브. 전원 연결 도는데 돌릴수도 있고 멈출수도 있다. 코어는 전기가 들어가면 명령하나하나 실행하는데 스탑도 가능하다 이 데이타 기반, 러닝중에 데이터 읽을 수 없고 멈출수도 없다. 실시간 중간중간 데이터 취득해서 읽어올 수 없다. 그래서 변수값 중간 중간 브레이크 포인트, 멈추고 메모리 읽고 레지스터 읽고 이런 것을 하게 되는, 실시간으로는 디버깅 아니다. 멈춰놓고 정보를 읽고 수정할 수 있게되는, 최신 mcu 들은 약간 어느정도 특정 경로 듀얼포트 뽑아서 데이터 뽑아서 읽을 수 있다. 그 옵션이 `DUALPORT`

dap2 선택

dapenable on

이제 시스템 업! 현재 리셋 상태, 이게 풀리면서 연결된다. 타겟, 코어에있는 내용 읽거나 수정 가능하다. 업!up

경고창 뜨면 다운 모드에서 전원 케이블 바꾸고 다시


창 설명

#### 라인넘버, 버추어 주소

코드 디스어셈블
왼쪽이 머신코드 
오른쪽이 디스어셈블

어셈블코드와 1대1 매칭

메모리에 머신코드는 그냥 저장되어 있는, 관심없는 것으로 신경쓰지 말아랑

디버거 일반적으로 명시하지 않으면 16진법


4바이트? 16진법 하나의 디지트는 4비트

명령어 픽스드 렝스 32비트, 16과섞어쓰는.
지금 섞여쓰는 모습, 파워피씨도 섞여쓰는. 메모리 효율 위해. 눈에 보이는 2바이트랑 4바이트 같이 보이는.

하이레벨 렝기지 ,주소 없는 것들은 하이레벨 랭기지다. 이건 16진법이 아니다. 저건 다룰수 있는게 아니고 볼수만 있는 거니까.


#### 라벨
main: 
이런 것들을 심볼이라 한다. 함수의 이름이 데이터타잎은 뭐냐? 포인터. 값이 주소가 들어가있고 

main (); 펑션콜오퍼레이션 연산자

연산자중에는 피연산자 1개 짜리 2개짜리 있는데 이건 1개만 받을 수 있는 연산자. 피연산자를 함수라는 타입. 그래서 그 타입이 있고 함수라는 타입은 이 연산을 해서 실행시킬 수 있고 실제 이게 연산했을 때 값으로 존재한다. 여기서는 

80000BB6 여기로 점프. 연산하는.



#### 니모닉

어셈블 문법으로 어셈블 코드. 그리고 

#### 코멘트.

디버거가 주소 정보 알려준다. 

밑에창.


#### 페리페럴, 스페셜펑션 맵핑 IO 다룰때 


#### 하이레벨 콜스텍 보여준다.

B:: 커멘드라인 인터패이스.

오른쪽 클릭후 명령입력

`B::Data.dump (0x70000000) /DIALOG /byte `

# 이제 Taking 창

print 직접 만들어야 한다.

ld 는 입구에다가 놓는거

함수 빠져나오는 위치에 같다놨다

시작명령어인데 끝에 갔다놨다? 스


하지만 A+B 이미 쓸데없는.. 아무곳에도 안들어있는,, 최적화 컴파일, 빌드, 컴파일. 옵션

이클립스

옵션은 빌드에서 주는.


디버깅 하이레벨에서 안된다. 최적화 0을 줘도 안된다. 메모리가 부족해서 안된다. 이거 모르면 사람 불러야한다.

# 오후

하이레벨에서는 메모리 볼 수 없다. 최적화 할 수 없다 어떻게 넘어가고 어떻게 만들어지는지 확인할 수 없다. 

성능. 메모리접근 횟수 적을수록 높아진다. 핵심, 더하기와 대입. 부가적인 스토어와 로드명령어로 따라오는게 너무 많다. 비효율적.

최적화 레벨 0으로도 된다. 기본으로 다 싹, 자원 충분하지 않기 때문에. 안그러면 다 들어가지 못한다. 특정 컴파일러, 다른 컴파일러쓰면 안들어가진다. 최적화 능력에 따라 ROM에 못 들어가는.


컴파일, gcc 설치하면 메뉴얼도 알아서 설치된다.

C:\Program Files (x86)\TASKING\TriCore v4.3r3\ctc\doc



C:\Program Files (x86)\TASKING\TriCore v4.3r3\ctc\bin

astc.exe

아카이브 a 만드는, 도구 추가로 달려있는, 얘네들을 통해서 개발할 때 지원도구




C:\Program Files (x86)\TASKING\TriCore v4.3r3\ctc\bin

경로 path 걸어라


ctc_user_guide.pdf

* Chapter 9. Using the Utilities
* Chapter 15. Linker Script Language (LSL)
* Chapter 7. Using the Assembler
* Chapter 8. Using the Linker
* Chapter 4. Using the C Compiler
  * 4.6. Compiler Optimizations
최소 이 정도는...



이 밑은 알고 있어야!

make utilities 오토사르도 make로.

링커 for gcc
rodata, data 0이 아니다.

bs 영영, 초기값 0
linker script
bin utilities 사용법




![058](./book/자율주행기능구현을위한차량용SW개발2_페이지_058.jpg)

링커보다 어렵다. 문서를 잘 봐야한다. 어셈블리 모르면 뭐가 잘못됐는지 모르는. 하이레벨 디버깅 안되기 때문에.

명령어 하나하나 니모닉 하나하나 이해하고 있어야 한다. 도구가 있어야 한다. 도구! 코어 메뉴얼보면

TriCore® TC1.6P & TC1.6E

볼륨1에서 

2 Programming Model 이거 필수 
3 General Purpose and System Registers
5 Interrupt System

익셉션 대신 트랩 이라하는데 트랩 어떻게 되는지. 알아야 한다. 이거 안읽으면 디버깅 못한다. 여기 정보는 로우레벨 정보. 시스템 다루는 사람의 정보다 상위만 하면 코어메뉴얼 볼 필요 없다. 하이레벨만으로는 부족하다 시스템 구축 힘들다. 제어, ECU 특히. 이 기능만으로는 안된다. 다른 기능들이 필요. 그때 이런 코어 알고 있어야.. 개발, 디버깅, 모두 알아야

`A[10] (stack pointer)`


볼륨2 어셈블리 공부하는 문서. 아이사문서 



Debug
* Programming Model(Programmers Model)
  * General Purpose Registers
  * Program Status Registers
  * Interrupt handling
  * Exception handling
* Assembly language
  * an execution unit
  * easy to understand
  * standard(X)
  * Debugging tool

![059](./book/자율주행기능구현을위한차량용SW개발2_페이지_059.jpg)

메모리 보고 인터럽트 보고 다양한 정보 확인 가능, 이렇게 문제 해결.

![060](./book/자율주행기능구현을위한차량용SW개발2_페이지_060.jpg)

특히 국산 디버거 쓰면 안된다. 안좋다. 쓰지 말아라. 안드로이드 든 스마트폰 오토사르 LG 삼성 다 디버그, 장점? 신뢰성. 믿고 쓰는 효율.

결국 때다 파는. ? 그럼 별로 못번다. 같이 기술지원에 다른 장비 부터 해줘야 많이 번다. 다 독점. 경쟁이 안된다. 

도구들을 잘 묶어서 통으로 턴킨? 패키지로 통채로 지원. v 사이클 모든 내용 지원 다 묶어서 지원, 만들어 하는 것은 안판다. 안팔린다. 신뢰성. 국책과제도 같이 켜서 조금 하긴 하지만 다 - 돈 벌수 없다. 좋은 도구

라우터바 최고의 부서! 가장 좋은 제품이면서 기술지원이 국내 젤 잘해준다. 인력이 엄청나게 수준이 올라가 있어서 그쪽은 올 수 있으면 많이 배울 수 있다. 프로젝트도 이런 것을 쓴느 업체들은 큰 회사고 큰 프로젝트 같이 할 수도 있다. 

sds1팀 좋다!? 다루는 아이템이 고수준 아이탬 기술력 고도화. 수준이 높아진다. 신입사원 주로 뽑는다. 같이 성장가능.

트라이코어 어셈블리

인피니언 코리아 없다.

물론 알고 있겠지만.

어셈블러 링커. 하나만 가지고는 안된다. 취업에서는. 다 잘해야한다.

시뮬링크 알고리즘, 수식 만들어내는것이 중요하다. 기본 베이스가 있어야 한다.

기계공학..


dt 사업부 하면 오트론
sds1팀 디스페이스.  힐? 하드웨어 인더룹 그런 장비 프로토타입.


ls오토모티브

sl tk? 

발레오 평화?

덴소 일본회사 부품회사



![061](./book/자율주행기능구현을위한차량용SW개발2_페이지_061.jpg)
![062](./book/자율주행기능구현을위한차량용SW개발2_페이지_062.jpg)
![063](./book/자율주행기능구현을위한차량용SW개발2_페이지_063.jpg)


---



갑오브 갑


![064](./book/자율주행기능구현을위한차량용SW개발2_페이지_064.jpg)

불친절, 파워트레인, 샤시 쪽 특화 인피니온 브랜드파워 엄청나다 c166

32비트 넘어가서 최초 mcu들 그게 트라이코어들. TriCore V1.6E&P 오릭스 AURIX 제품군. 오도AUDO 라는 것도 있었는데 흥행 못해서 단종

암도 한다. 

Tric
v

파워트레인 엔진 내부 

샤시 차체제어 






![065](./book/자율주행기능구현을위한차량용SW개발2_페이지_065.jpg)

그리고 기능들.

* 케쉬단만 하버드, 나머지는 폰노이만.
* reduce instruction 감소된 명령어. 하지만 역시나 많다. 
* 슈퍼스칼라
  * ALU 2,3개, 병렬로 처리
* 4 GByte 4*10^9*byte ???
  * 바이너리는 단위가 다르다. 바이너리 단위는 

|||
|:---:|:---:|
|$10^3$|1024|
|$10^6$|$1024^2$|
|$10^9$|$1024^3$|

4*10^9 
4294967296 - 1 = 4294967295 이게 마지막 주소 이게 1바이트 저장할 수 있는.

4기가 접근한다는 것은 0번지부터  FFFF.FFFF 마지막 주소까지

32비트 어드레스 표현하기 위해서 32비트 필요. 포인터가 그만큼. 


바이너리 월드, 데시멀 월드가 다르다.

한 클럭당 하나의 결과 나오게, 대부분의 명령어가 1클럭에 끝나게.



Key features
* 32 bit Harvard architecture
* RISC architecture
* Superscalar architecture
* Little-endian byte ordering
* 4 GByte address space
* 16 &. 32 bit instructions
* Most instruction executed in 1 cycle
  * 인서트, 익스트렉트, 그게 1개짜리 명령어가 있다. 제어쪽에 굉장히 특화가 있다.
* Bit handling
* Flexible interrupt prioritization scheme
* Low interrupt latency
  * 엄청 빠르다? 3사이클이면 된다?
* Fast context switching
  * 함수콜? 레지스터 백업, 엄청 빠르다.
* Dual MAC unit
  * 연산의 효율 좋을 수 있다.
  * 속도 빠른, 맥이 2개있다는.
* Zero Overhead Loop
  * 독특한 기능? 디버깅할때 루프 for while dowhile 루프돌때 오버헤드가 상당히 크다, 루프에 대한 오버헤드가 없다. 파이프라인이 깨진다???디버깅할때 y값 증감 볼 수 없다? 굉장히 빨라서 증가하고 한단하고 보고 이런 게 없는. 너무 빨라서. 모든 코어에 FPU가 달려있다. FPU 없으면 1.1+1.1 100사이클 도는.
* FPU
* 디바이드, 역시 100사이클. 얘는 디바이드까지 있어서 성능 많이 끌어올릴 수 있게!







![066](./book/자율주행기능구현을위한차량용SW개발2_페이지_066.jpg)

코드와 데이터 불리 그게 하버드 아키텍쳐 32비트 아니다. 왼쪽 64 오르ㄴ쪽 128, 데이터용 어그레스용 2개 있는 이유가 ! 엄청 좋다.

1번 읽어오면 명령어 4개 읽어오는? 여길 벗어나는 부분이 폰노이만. 



~~

로드스토어를 통해서 LED를 켠다?


![067](./book/자율주행기능구현을위한차량용SW개발2_페이지_067.jpg)

코어버전 2개 P버전은 퍼포먼스 버전 300메가 헤르트 E 버전 이피션시 버전 속도 떨어져도 전력소모 줄이는, 하드웨어 구조 다르다. 슈퍼스칼라 방법.


이피션시 버전.

슈퍼스칼라라면 하버드 아니라도 병렬호로. 진짜 연산은 +- 이건 1개밖에 없어서 싱글이슈. 그런 스칼라

![068](./book/자율주행기능구현을위한차량용SW개발2_페이지_068.jpg)


* Integer pipeline:
  * Integer arithmetic and logic instructions.
  * Bit operations.
  * Divide and MAC instructions.
* Load/Store pipeline:
  * Load / Store instructions.
  * Context operations.
  * Address arithmetic instructions.
  * Loop pipeline:
  * Loop instructions.



![069](./book/자율주행기능구현을위한차량용SW개발2_페이지_069.jpg)



어셈블리 할 때 알고 건드려야 한다. 알고 건드려야 하는. 한 클럭에 무조건 3개, 조합이 있고 순서가 있어서 항상 트리플로 이슈가 되서 슈퍼스칼라 다 돌리면 최고의 성능, 그건 불가능 1클럭당 1.3 정도 밖에 못쓴다. 2개짜리도 저만큼만, 저 구조를 3개가 한방에 들어가게끔 

트리플이슈. 연산한번 로드/스토어 한번 루프한번.
듀얼이슈. 

버블. 한클럭을 버려버리는, 버블, 효율 안나오는. 


슈퍼스칼라


Super-scalar execution
1234 5 67
Id.a a3, [a2]0 ;11
Id.a a4, [aS]O ;12
Decode - - i1 i2 i3
Integer
Execute i1 i2 i3
Pipeline
add dl, d2,d3 ;il Write Back i1 i2 i3
add d4,d5, d6 ;i2 Decode 11 12
sub d7, dB, d9 ;i3 us Pipeline Execute 11 12
Write Back 11 12
1234 5 6 7
Decode i1 i2 i3
add dl, d2, d3 ;il
add d4, dS, d6 ;i2
Integer
Pipeline Execute i1 i2 i3
Id .a a3, [a2]0 ;11 Write Back i1 i2 i3
sub d7, dB, d9 ;i3 Decode - 11 12
Id.a a4, [aS]O ;12 us
Pipeline Execute 11 12
Write Back 11 12




![070](./book/자율주행기능구현을위한차량용SW개발2_페이지_070.jpg)

AP 고급용 AP 암 가은 코어텍스 A 어플리케이션 전용 고성능, FPU 연산 많은. FPU 전용 레지스터 있다.피연산자들의 역할 테이터 처리 공간. 전용에 놓고 쓰면 빠르기에. 예네는 제어용이니까 인티저 레지스터 같이 활용?

DIV.F 있는게 어디! 단 15클럭. 




FPU 잘 봐야한다.

32bit Floating point Unit in all CPUs

single precision according to IEEE-754 미쓰라 코딩룰? 체크 확인해야한다
알고 해라. 성능하고 모두 영향.


#
실습 컴파일열어봐라


`B::sys.up `
리셋명령어. 엔트리 포인터로 떠러진다. 스타트포인터, 전원 인가됐을때 첫번째로 시작되는 주소. 그건 다 다르다.

A0000020 오릭스의 엔트리 포인트



`go main`

심볼 사이 명령 다 실행에서 go main에서 멈춰라.
메인 없으면 나올때까지. 심볼은 대소문자까지


jtap 앞으로만. 리버스안되고  trace32리버스도 된다. 백업하고 역으로 넣어주는... 


옵션의 디폴트 값이 더블이 플롯팅 으로 인식하게 되어있다 .그래야 속도 빠르니까. 그래서 

3 2bit Floating Point Unit in all CPUs:
* Single precision according to I EEE-754
* 2 FLOPs per cycle (pipelined)

포멧에 맞춰서 연산할 수 있게 맞춰서.


6.625+1.1 

double precision

70 스텝... 

single precision

4 스텝


C 언어 우낀게 옵션에따라, 컴파일러 옵션세팅에 따라 엄청나게 바귈 수 있다.

꼭 데이터타입 확인하고 인코딩 형태 확인하고 작업하라.!


![071](./book/자율주행기능구현을위한차량용SW개발2_페이지_071.jpg)

스페셜 퍼포스 레지스터

이거 없으면 컴퓨터 운영하는데 힘들다. PC SP RA(LR) 더 있는데 그거 있으면 효율 있지만 어쨌든 이거 없으면 C 언어, 스텍 관리 힘들다. 


* PC 프로그램 카운터
  * 현재 실행하는 명령어의 주소. 지금실행하는 명령어의 주소.
  * 이건 시스템 레지스터에 있다. 
* SP 스텍 FILO 최상위 푸쉬팟 동작운영 해야한니까
* RA(LA) 리턴 어드레스 링크 어드레스 C 언어 펑션콜 할때 필요


FP 프레임포인트? 없어도 됨. 스텍 밑에 필수 아님.































![072](./book/자율주행기능구현을위한차량용SW개발2_페이지_072.jpg)
![073](./book/자율주행기능구현을위한차량용SW개발2_페이지_073.jpg)
![074](./book/자율주행기능구현을위한차량용SW개발2_페이지_074.jpg)
![075](./book/자율주행기능구현을위한차량용SW개발2_페이지_075.jpg)
![076](./book/자율주행기능구현을위한차량용SW개발2_페이지_076.jpg)
![077](./book/자율주행기능구현을위한차량용SW개발2_페이지_077.jpg)
![078](./book/자율주행기능구현을위한차량용SW개발2_페이지_078.jpg)
![079](./book/자율주행기능구현을위한차량용SW개발2_페이지_079.jpg)
![080](./book/자율주행기능구현을위한차량용SW개발2_페이지_080.jpg)
![081](./book/자율주행기능구현을위한차량용SW개발2_페이지_081.jpg)
![082](./book/자율주행기능구현을위한차량용SW개발2_페이지_082.jpg)
![083](./book/자율주행기능구현을위한차량용SW개발2_페이지_083.jpg)
![084](./book/자율주행기능구현을위한차량용SW개발2_페이지_084.jpg)
![085](./book/자율주행기능구현을위한차량용SW개발2_페이지_085.jpg)
![086](./book/자율주행기능구현을위한차량용SW개발2_페이지_086.jpg)
![087](./book/자율주행기능구현을위한차량용SW개발2_페이지_087.jpg)
![088](./book/자율주행기능구현을위한차량용SW개발2_페이지_088.jpg)
![089](./book/자율주행기능구현을위한차량용SW개발2_페이지_089.jpg)
![090](./book/자율주행기능구현을위한차량용SW개발2_페이지_090.jpg)
![091](./book/자율주행기능구현을위한차량용SW개발2_페이지_091.jpg)
![092](./book/자율주행기능구현을위한차량용SW개발2_페이지_092.jpg)
![093](./book/자율주행기능구현을위한차량용SW개발2_페이지_093.jpg)
![094](./book/자율주행기능구현을위한차량용SW개발2_페이지_094.jpg)
![095](./book/자율주행기능구현을위한차량용SW개발2_페이지_095.jpg)
![096](./book/자율주행기능구현을위한차량용SW개발2_페이지_096.jpg)
![097](./book/자율주행기능구현을위한차량용SW개발2_페이지_097.jpg)
![098](./book/자율주행기능구현을위한차량용SW개발2_페이지_098.jpg)
![099](./book/자율주행기능구현을위한차량용SW개발2_페이지_099.jpg)
![100](./book/자율주행기능구현을위한차량용SW개발2_페이지_100.jpg)
![101](./book/자율주행기능구현을위한차량용SW개발2_페이지_101.jpg)
![102](./book/자율주행기능구현을위한차량용SW개발2_페이지_102.jpg)
![103](./book/자율주행기능구현을위한차량용SW개발2_페이지_103.jpg)
![104](./book/자율주행기능구현을위한차량용SW개발2_페이지_104.jpg)
![105](./book/자율주행기능구현을위한차량용SW개발2_페이지_105.jpg)
![106](./book/자율주행기능구현을위한차량용SW개발2_페이지_106.jpg)
![107](./book/자율주행기능구현을위한차량용SW개발2_페이지_107.jpg)
![108](./book/자율주행기능구현을위한차량용SW개발2_페이지_108.jpg)
![109](./book/자율주행기능구현을위한차량용SW개발2_페이지_109.jpg)
![110](./book/자율주행기능구현을위한차량용SW개발2_페이지_110.jpg)
![111](./book/자율주행기능구현을위한차량용SW개발2_페이지_111.jpg)
![112](./book/자율주행기능구현을위한차량용SW개발2_페이지_112.jpg)
![113](./book/자율주행기능구현을위한차량용SW개발2_페이지_113.jpg)
![114](./book/자율주행기능구현을위한차량용SW개발2_페이지_114.jpg)
![115](./book/자율주행기능구현을위한차량용SW개발2_페이지_115.jpg)
![116](./book/자율주행기능구현을위한차량용SW개발2_페이지_116.jpg)
![117](./book/자율주행기능구현을위한차량용SW개발2_페이지_117.jpg)
![118](./book/자율주행기능구현을위한차량용SW개발2_페이지_118.jpg)
![119](./book/자율주행기능구현을위한차량용SW개발2_페이지_119.jpg)
![120](./book/자율주행기능구현을위한차량용SW개발2_페이지_120.jpg)
![121](./book/자율주행기능구현을위한차량용SW개발2_페이지_121.jpg)
![122](./book/자율주행기능구현을위한차량용SW개발2_페이지_122.jpg)
![123](./book/자율주행기능구현을위한차량용SW개발2_페이지_123.jpg)
![124](./book/자율주행기능구현을위한차량용SW개발2_페이지_124.jpg)
![125](./book/자율주행기능구현을위한차량용SW개발2_페이지_125.jpg)
![126](./book/자율주행기능구현을위한차량용SW개발2_페이지_126.jpg)
![127](./book/자율주행기능구현을위한차량용SW개발2_페이지_127.jpg)
![128](./book/자율주행기능구현을위한차량용SW개발2_페이지_128.jpg)
![129](./book/자율주행기능구현을위한차량용SW개발2_페이지_129.jpg)
![130](./book/자율주행기능구현을위한차량용SW개발2_페이지_130.jpg)
![131](./book/자율주행기능구현을위한차량용SW개발2_페이지_131.jpg)
![132](./book/자율주행기능구현을위한차량용SW개발2_페이지_132.jpg)
![133](./book/자율주행기능구현을위한차량용SW개발2_페이지_133.jpg)
![134](./book/자율주행기능구현을위한차량용SW개발2_페이지_134.jpg)
![135](./book/자율주행기능구현을위한차량용SW개발2_페이지_135.jpg)
![136](./book/자율주행기능구현을위한차량용SW개발2_페이지_136.jpg)
![137](./book/자율주행기능구현을위한차량용SW개발2_페이지_137.jpg)
![138](./book/자율주행기능구현을위한차량용SW개발2_페이지_138.jpg)
![139](./book/자율주행기능구현을위한차량용SW개발2_페이지_139.jpg)
![140](./book/자율주행기능구현을위한차량용SW개발2_페이지_140.jpg)
![141](./book/자율주행기능구현을위한차량용SW개발2_페이지_141.jpg)
![142](./book/자율주행기능구현을위한차량용SW개발2_페이지_142.jpg)
![143](./book/자율주행기능구현을위한차량용SW개발2_페이지_143.jpg)
![144](./book/자율주행기능구현을위한차량용SW개발2_페이지_144.jpg)
![145](./book/자율주행기능구현을위한차량용SW개발2_페이지_145.jpg)
![146](./book/자율주행기능구현을위한차량용SW개발2_페이지_146.jpg)
![147](./book/자율주행기능구현을위한차량용SW개발2_페이지_147.jpg)
![148](./book/자율주행기능구현을위한차량용SW개발2_페이지_148.jpg)
![149](./book/자율주행기능구현을위한차량용SW개발2_페이지_149.jpg)
![150](./book/자율주행기능구현을위한차량용SW개발2_페이지_150.jpg)
![151](./book/자율주행기능구현을위한차량용SW개발2_페이지_151.jpg)
![152](./book/자율주행기능구현을위한차량용SW개발2_페이지_152.jpg)
![153](./book/자율주행기능구현을위한차량용SW개발2_페이지_153.jpg)
![154](./book/자율주행기능구현을위한차량용SW개발2_페이지_154.jpg)
![155](./book/자율주행기능구현을위한차량용SW개발2_페이지_155.jpg)
![156](./book/자율주행기능구현을위한차량용SW개발2_페이지_156.jpg)
![157](./book/자율주행기능구현을위한차량용SW개발2_페이지_157.jpg)
![158](./book/자율주행기능구현을위한차량용SW개발2_페이지_158.jpg)
![159](./book/자율주행기능구현을위한차량용SW개발2_페이지_159.jpg)
![160](./book/자율주행기능구현을위한차량용SW개발2_페이지_160.jpg)
![161](./book/자율주행기능구현을위한차량용SW개발2_페이지_161.jpg)
![162](./book/자율주행기능구현을위한차량용SW개발2_페이지_162.jpg)
![163](./book/자율주행기능구현을위한차량용SW개발2_페이지_163.jpg)
![164](./book/자율주행기능구현을위한차량용SW개발2_페이지_164.jpg)
![165](./book/자율주행기능구현을위한차량용SW개발2_페이지_165.jpg)
![166](./book/자율주행기능구현을위한차량용SW개발2_페이지_166.jpg)
![167](./book/자율주행기능구현을위한차량용SW개발2_페이지_167.jpg)
![168](./book/자율주행기능구현을위한차량용SW개발2_페이지_168.jpg)
![169](./book/자율주행기능구현을위한차량용SW개발2_페이지_169.jpg)
![170](./book/자율주행기능구현을위한차량용SW개발2_페이지_170.jpg)
![171](./book/자율주행기능구현을위한차량용SW개발2_페이지_171.jpg)
![172](./book/자율주행기능구현을위한차량용SW개발2_페이지_172.jpg)
![173](./book/자율주행기능구현을위한차량용SW개발2_페이지_173.jpg)
![174](./book/자율주행기능구현을위한차량용SW개발2_페이지_174.jpg)
![175](./book/자율주행기능구현을위한차량용SW개발2_페이지_175.jpg)
![176](./book/자율주행기능구현을위한차량용SW개발2_페이지_176.jpg)
![177](./book/자율주행기능구현을위한차량용SW개발2_페이지_177.jpg)
![178](./book/자율주행기능구현을위한차량용SW개발2_페이지_178.jpg)
![179](./book/자율주행기능구현을위한차량용SW개발2_페이지_179.jpg)
![180](./book/자율주행기능구현을위한차량용SW개발2_페이지_180.jpg)
![181](./book/자율주행기능구현을위한차량용SW개발2_페이지_181.jpg)
![182](./book/자율주행기능구현을위한차량용SW개발2_페이지_182.jpg)
![183](./book/자율주행기능구현을위한차량용SW개발2_페이지_183.jpg)
![184](./book/자율주행기능구현을위한차량용SW개발2_페이지_184.jpg)
![185](./book/자율주행기능구현을위한차량용SW개발2_페이지_185.jpg)
![186](./book/자율주행기능구현을위한차량용SW개발2_페이지_186.jpg)
![187](./book/자율주행기능구현을위한차량용SW개발2_페이지_187.jpg)
![188](./book/자율주행기능구현을위한차량용SW개발2_페이지_188.jpg)
![189](./book/자율주행기능구현을위한차량용SW개발2_페이지_189.jpg)
![190](./book/자율주행기능구현을위한차량용SW개발2_페이지_190.jpg)
![191](./book/자율주행기능구현을위한차량용SW개발2_페이지_191.jpg)
![192](./book/자율주행기능구현을위한차량용SW개발2_페이지_192.jpg)
![193](./book/자율주행기능구현을위한차량용SW개발2_페이지_193.jpg)
![194](./book/자율주행기능구현을위한차량용SW개발2_페이지_194.jpg)
![195](./book/자율주행기능구현을위한차량용SW개발2_페이지_195.jpg)
![196](./book/자율주행기능구현을위한차량용SW개발2_페이지_196.jpg)
![197](./book/자율주행기능구현을위한차량용SW개발2_페이지_197.jpg)
![198](./book/자율주행기능구현을위한차량용SW개발2_페이지_198.jpg)
![199](./book/자율주행기능구현을위한차량용SW개발2_페이지_199.jpg)
![200](./book/자율주행기능구현을위한차량용SW개발2_페이지_200.jpg)
![201](./book/자율주행기능구현을위한차량용SW개발2_페이지_201.jpg)
![202](./book/자율주행기능구현을위한차량용SW개발2_페이지_202.jpg)
![203](./book/자율주행기능구현을위한차량용SW개발2_페이지_203.jpg)
![204](./book/자율주행기능구현을위한차량용SW개발2_페이지_204.jpg)
![205](./book/자율주행기능구현을위한차량용SW개발2_페이지_205.jpg)
![206](./book/자율주행기능구현을위한차량용SW개발2_페이지_206.jpg)
![207](./book/자율주행기능구현을위한차량용SW개발2_페이지_207.jpg)
![208](./book/자율주행기능구현을위한차량용SW개발2_페이지_208.jpg)
![209](./book/자율주행기능구현을위한차량용SW개발2_페이지_209.jpg)
![210](./book/자율주행기능구현을위한차량용SW개발2_페이지_210.jpg)
![211](./book/자율주행기능구현을위한차량용SW개발2_페이지_211.jpg)
![212](./book/자율주행기능구현을위한차량용SW개발2_페이지_212.jpg)
![213](./book/자율주행기능구현을위한차량용SW개발2_페이지_213.jpg)
![214](./book/자율주행기능구현을위한차량용SW개발2_페이지_214.jpg)
![215](./book/자율주행기능구현을위한차량용SW개발2_페이지_215.jpg)
![216](./book/자율주행기능구현을위한차량용SW개발2_페이지_216.jpg)
![217](./book/자율주행기능구현을위한차량용SW개발2_페이지_217.jpg)
![218](./book/자율주행기능구현을위한차량용SW개발2_페이지_218.jpg)
![219](./book/자율주행기능구현을위한차량용SW개발2_페이지_219.jpg)
![220](./book/자율주행기능구현을위한차량용SW개발2_페이지_220.jpg)
![221](./book/자율주행기능구현을위한차량용SW개발2_페이지_221.jpg)
![222](./book/자율주행기능구현을위한차량용SW개발2_페이지_222.jpg)
![223](./book/자율주행기능구현을위한차량용SW개발2_페이지_223.jpg)
![224](./book/자율주행기능구현을위한차량용SW개발2_페이지_224.jpg)
![225](./book/자율주행기능구현을위한차량용SW개발2_페이지_225.jpg)
![226](./book/자율주행기능구현을위한차량용SW개발2_페이지_226.jpg)
![227](./book/자율주행기능구현을위한차량용SW개발2_페이지_227.jpg)
![228](./book/자율주행기능구현을위한차량용SW개발2_페이지_228.jpg)
![229](./book/자율주행기능구현을위한차량용SW개발2_페이지_229.jpg)
![230](./book/자율주행기능구현을위한차량용SW개발2_페이지_230.jpg)
![231](./book/자율주행기능구현을위한차량용SW개발2_페이지_231.jpg)
![232](./book/자율주행기능구현을위한차량용SW개발2_페이지_232.jpg)
![233](./book/자율주행기능구현을위한차량용SW개발2_페이지_233.jpg)
![234](./book/자율주행기능구현을위한차량용SW개발2_페이지_234.jpg)
![235](./book/자율주행기능구현을위한차량용SW개발2_페이지_235.jpg)
![236](./book/자율주행기능구현을위한차량용SW개발2_페이지_236.jpg)
![237](./book/자율주행기능구현을위한차량용SW개발2_페이지_237.jpg)
![238](./book/자율주행기능구현을위한차량용SW개발2_페이지_238.jpg)
![239](./book/자율주행기능구현을위한차량용SW개발2_페이지_239.jpg)
![240](./book/자율주행기능구현을위한차량용SW개발2_페이지_240.jpg)
![241](./book/자율주행기능구현을위한차량용SW개발2_페이지_241.jpg)
![242](./book/자율주행기능구현을위한차량용SW개발2_페이지_242.jpg)
![243](./book/자율주행기능구현을위한차량용SW개발2_페이지_243.jpg)
![244](./book/자율주행기능구현을위한차량용SW개발2_페이지_244.jpg)
![245](./book/자율주행기능구현을위한차량용SW개발2_페이지_245.jpg)
![246](./book/자율주행기능구현을위한차량용SW개발2_페이지_246.jpg)
![247](./book/자율주행기능구현을위한차량용SW개발2_페이지_247.jpg)
![248](./book/자율주행기능구현을위한차량용SW개발2_페이지_248.jpg)
![249](./book/자율주행기능구현을위한차량용SW개발2_페이지_249.jpg)
![250](./book/자율주행기능구현을위한차량용SW개발2_페이지_250.jpg)
![251](./book/자율주행기능구현을위한차량용SW개발2_페이지_251.jpg)
![252](./book/자율주행기능구현을위한차량용SW개발2_페이지_252.jpg)
![253](./book/자율주행기능구현을위한차량용SW개발2_페이지_253.jpg)
![254](./book/자율주행기능구현을위한차량용SW개발2_페이지_254.jpg)
![255](./book/자율주행기능구현을위한차량용SW개발2_페이지_255.jpg)
![256](./book/자율주행기능구현을위한차량용SW개발2_페이지_256.jpg)
![257](./book/자율주행기능구현을위한차량용SW개발2_페이지_257.jpg)
![258](./book/자율주행기능구현을위한차량용SW개발2_페이지_258.jpg)
![259](./book/자율주행기능구현을위한차량용SW개발2_페이지_259.jpg)
![260](./book/자율주행기능구현을위한차량용SW개발2_페이지_260.jpg)
![261](./book/자율주행기능구현을위한차량용SW개발2_페이지_261.jpg)
![262](./book/자율주행기능구현을위한차량용SW개발2_페이지_262.jpg)
![263](./book/자율주행기능구현을위한차량용SW개발2_페이지_263.jpg)
![264](./book/자율주행기능구현을위한차량용SW개발2_페이지_264.jpg)
![265](./book/자율주행기능구현을위한차량용SW개발2_페이지_265.jpg)
![266](./book/자율주행기능구현을위한차량용SW개발2_페이지_266.jpg)
![267](./book/자율주행기능구현을위한차량용SW개발2_페이지_267.jpg)
![268](./book/자율주행기능구현을위한차량용SW개발2_페이지_268.jpg)
![269](./book/자율주행기능구현을위한차량용SW개발2_페이지_269.jpg)
![270](./book/자율주행기능구현을위한차량용SW개발2_페이지_270.jpg)
![271](./book/자율주행기능구현을위한차량용SW개발2_페이지_271.jpg)
![272](./book/자율주행기능구현을위한차량용SW개발2_페이지_272.jpg)
![273](./book/자율주행기능구현을위한차량용SW개발2_페이지_273.jpg)
![274](./book/자율주행기능구현을위한차량용SW개발2_페이지_274.jpg)
![275](./book/자율주행기능구현을위한차량용SW개발2_페이지_275.jpg)
![276](./book/자율주행기능구현을위한차량용SW개발2_페이지_276.jpg)
![277](./book/자율주행기능구현을위한차량용SW개발2_페이지_277.jpg)
![278](./book/자율주행기능구현을위한차량용SW개발2_페이지_278.jpg)
![279](./book/자율주행기능구현을위한차량용SW개발2_페이지_279.jpg)
![280](./book/자율주행기능구현을위한차량용SW개발2_페이지_280.jpg)
![281](./book/자율주행기능구현을위한차량용SW개발2_페이지_281.jpg)
![282](./book/자율주행기능구현을위한차량용SW개발2_페이지_282.jpg)
![283](./book/자율주행기능구현을위한차량용SW개발2_페이지_283.jpg)
![284](./book/자율주행기능구현을위한차량용SW개발2_페이지_284.jpg)
![285](./book/자율주행기능구현을위한차량용SW개발2_페이지_285.jpg)







---
[다시 # week 8 index 로](../w08.md)

[다시 # 전 과정 main 으로](../../README.md)

