***5주차 2일짜 20190611 수업***

***20190611 마지막업데이트***

# Week 5 - Day 2 - 차량용 프로세서 디바이스 제어


![](https://d.pr/i/KAQLxD+)

![](https://d.pr/n/9p21YB+)

## pull-up and pull-down

<!-- ![](./img/0611_0920_001.png) -->

풀업, 풀다운 설정 하는 레지스터 있는지 확인.

GPE14 찾았고 I2C 로 쓰려면 비트 10으로 ***얼터네이티브 펑션 제3의 기능*** 

![](./img/0611_001.png)
![](./img/0611_002.png)
![](./img/0611_003.png)

## UART

![](./img/0611_004.png)

rs232c 트렌시버

![](./img/0611_005.png)

50년전 만들어진 기술

I2C는 무조건 풀업ㅈ더항으로 달아야 한다. 그래서 메뉴얼보고 회로도 보고 풀업 없으니까 외부설계시 달아줘야한다. 안달아도 되고 이미 있다면 믿고 쓰면 된다!

디지털을 보내고 받는 장치

`hexdump -C exception.o |more`

![](./img/0611_006.png)
![](./img/0611_008.png)
![](./img/0611_009.png)

'\n' (줄바꿈) 0x0a 개행 

동조

BPS 1초에 몇번을 보내는, 115,200bps 다 하면 초당 115200 bit를 보내는 속도

비동기 
* 한줄로 보내는, 시작비트와 정지비트로 싱크를 맞추는게

동기
* 두줄로 보내는, 동기는 IIC 클럭과 data로 나눠서 



```c
#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
```
```c
WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)='h'
```

```c
void Uart_Init(int baud)
{
	int pclk;   
	pclk = PCLK;    // AMBA APB 버스클럭
```
암바버스

https://blog.naver.com/guile21c/52117520

usb, pcl i2c 정보가 전달되는 파이프라인, 버스

arm 사에서 만든? amba 버스. arm 사의 버스규격. arm soc에선 이 버스만 사용. 



다 묶어서 amba라 부른다.
![](https://postfiles.pstatic.net/data32/2008/6/19/154/image22162406191_guile21c.gif?type=w2)

ahb asb 하이 고속도로
apb 로우 지방도로 국도

uart도 cpu처럼 66m 클럭이다? 그럼 apb클럭이 66m

같은 동일 클럭이 66m 클럭으로 돈다.



![](./img/0611_010.png)

```c option.h
// Frequency setting

#define	FCLK		534000000	// 534.000MHz (400MHz)
#define	HCLK		(FCLK/4)		// 133.000MHz (100MHz)
#define	PCLK		(FCLK/8)		// 66.0000MHz (50MHz)
```


```
UART 설정
ULCON – connection 관련 설정
UCON – UART 내부 동작 설정
UFCON – FIFO 설정
UMCON – flow control 설정
UBRDIV – baud rate (속도) 설정

Status
UTRSTAT – 데이터 전송 상태
UERSTAT – 에러 상태
UFSTAT – FIFO 상태
UMSTAT – flow control 관련 상태

Data 레지스터
UTXH – TX buffer 레지스터
URXH – RX buffer 레지스터
```


`rGPHCON = (rGPHCON &~ (0xF<<4))|(0xA<<4);`

![](./img/0611_011.png)

모두 위에 0인 이유 아무리 뭘 건드려도 
결국 FIFO가 0 이니까 그 안에 다른 걸 건드려도 어차피 꺼 있으니까 상관이 없다.

2.1.9 Infrared (IR) Mode

적외선 UART 기능 ULCONn 안쓰니까 0
패리티비트. 





```c
void Uart_Send_String(char *pt)  
{
    while((*pt)!='\0')
    {
        Uart_Send_Byte(*pt);
        pt++;           // 문자 하나씩 증가시키면서 문자열 출력
    }
}
```


```c
void Uart_Send_Byte(int data)
{
    if(data=='\n')                      //개행문자
    {
        while(!(rUTRSTAT1 & 0x2));
        WrUTXH1('\r');
    }

    /* TODO : UTRSTAT0의 값을 확인하여 TX 버퍼가 비어있으면 문자 출력   */ 
    //Tx 부에서는 일단 Transmit Buffer을 비워주고 ; 왜냐면? 내꺼만 쓸라고...
    //레지스터에 값을 기록 한다. 
    //Transmit Shifter로 적재 
    //기록된 값은 baud rate에 맞춰 송신

    while(!(rUTRSTAT1 & 0x2));	
    WrUTXH1(data);
}
```

```c
char Uart_GetChar(void)
{
    /* UTRSTAT1의 값을 확인하여 문자열 입력   */	
    // rUTRSTAT1
    // rUTRSTAT0 init => 0 , 값이 들어올 때까지 while문 계속 돌면서 대기 모드
    // receiver buffer에 값이 들어오면 1로 바뀌면서 while 문 빠져나가고
    // 문자를 찍는다.
    while(!(rUTRSTAT1 & 0x1));
        return rURXH1;              //0x50000024 주소에 있는 값
}
```



![](./img/0611_012.png)
![](./img/0611_013.png)
![](./img/0611_014.png)
![](./img/0611_015.png)






<!-- ![](./img/0611_001.png)
![](./img/0611_002.png)
![](./img/0611_003.png)
![](./img/0611_004.png)
![](./img/0611_005.png)
![](./img/0611_006.png)
![](./img/0611_007.png)
![](./img/0611_008.png)
![](./img/0611_009.png)
![](./img/0611_010.png)
![](./img/0611_011.png)
![](./img/0611_012.png)
![](./img/0611_013.png)
![](./img/0611_014.png)
![](./img/0611_015.png) -->

---
[다시 # week 5 index 로](../w05.md)

[다시 # 전 과정 main 으로](../../README.md)

