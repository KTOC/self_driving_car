<!-- 
Python 관런 서적은 처음 가져본다. 온라인으로, 오픈소스로, 무료pdf 서적으로 혼자 코드를 뜯어보면서 공부했었는데 커리큘럼 상 단 4일짜리 파이썬 교육이 있고 무거운 책도 나눠주기에 다시 한번 정리하면서 곱씹어보려한다. 전반적으로 강사님도 내 스타일이 아니고(분명 좋으신 분이지만, 1주차 강사님처럼 수준별 강의와 프로젝트식 강의가 너무 좋았기에....) 책은 더더욱 아니지만(이 책은 파이썬으로 이런 것들 모두 할 수 있어~ 라는 걸 가볍게 보여주는 책이니..) 어쨌거나 저쨌거나 나는 파이썬이 그나마 제일 익숙(?) 하니 그럴지도 모르기도 하지만서도...

언젠가 내가 파이썬을 유튜브에 강의를 하게 되면 어떻게 할까를 예전에 공부하면서 많이 생각해 봤는데 그 첫 단락이 `왜 파이썬인가?` 였다. 근데 이번 강사님은 그게 전혀 없이 그냥 C와 C++을 비교한 수업을 진행하셨다. 물론 임베디드니 그럴 수 있지만 반대로 생각해보면 임베디드에서 파이썬을 배울 필요가 없는 것이 아닐까?  -->

`왜 파이썬인가?` 아니 `왜 임베디드에서도 파이썬인가?` 에 대한 물음에 해답은 들을 수 없었지만. 그거 찾으려고 이렇게 공부하는게 아닐까.  

# 책 정리

아래 내용은 책을 보면서 이것 만큼은 꼭 까먹지 말자 느낌으로 가볍게 옮겼다.

## 2장

* 리터럴 
  * 3, 3.14, "I Love python"
  * 변하지 않고 고정된 데이터 자체의 표현

## 3장

* C 정적 타이핑
* Python 은 동적 타이핑
* Python 은 변수에 데이터를 대입하면 변수가 데이터를 직접 참조하는 것이 아니다.
* Python 은 모든 데이터가 파이썬이 제공하는 특수한 형태의 객체로 둘러쌓여 있다.
  * 그래서 타입 선언 불필요(이미 정해져 있으니까)

### 객체
* 객체 내부로 접근하기 위해서 이 객체를 참조하는 변수를 통해서 접근해야 한다.
    ```python
    >>> spell_object.print_spell()
    Hello World
    ```
* 어트리뷰트(속성)과 메쏘드
  * 위에서 객체 내부의 데이터를 담은 변수 `spell_object` 가 객체
  * `spell = "Hello World"` 는 `Atribute` 속성
  * `print_spell()` 그 안에 있는 함수는 `메쏘드`
  * `.` 은 속성접근자

## 4장

* 4 built-in data type
  * number type
  * sequences type
  * set type
  * mappings type
* `is 연산` 과 `== 연산`
  * -5~256 까지의 숫자는 한번만 생성
  * 그 외의 숫자는 생성될 때마다 새롭게 생성
  * is는 id 값을 비교하는 연산
  * == 내부 값을 비교하는 연산
* *사칙연산시 낮은 자료형은 승격*
* 쉬프트연산 ***8421코드***

## 5장 

* 깊은 복사를 하는 이유는 동일한 데이터를 가진 객체를 새롭게 생성하기 위한 것
* 리스트`[]`와 튜플`()`
  * 튜플의 메모리가 더 적게 소모된다
  * 튜플은 수정이 불가하기 때문에 안정, 보안의 목적으로 사용된다.
    ```python
    >>>'python' in s
    false
    ```
* `eval()` 문자열 연산처리
* `capitalize()` 첫문자 대문자
* `casefold()` 소문자, 문자열비교
* `insert(index, object)`
* `pop()` 내용 지우면서 출력
* `deepcopy()`
* `copy()`
* 튜플
  * `mytuple=()`    # 이렇게 하면 연산자
  * `mytuple=(1,)`  # 이렇게 해야 튜플 가능
  * `from collections import namedtuple`

## 6장

* 4 built-in data type
  * mappings type

Dictionary

* `update`
* `setdefault`
* key 존재 여부 확인
    ```python
        dict_test = {'first':7, 'second':77, 'third':777}
        x = {'first':0, 'end':100}      # 추가하려는 사전

        for my_key in x:
            if my_key not in dict_test:
                dict_test.update({my_key:x[my_key]})
    ```
* 항목삭제 
  * list나 dict 은 del 연산자 사용    

변환
* dictionary에서
  * 튜플로
    * `.items()` 리스트 형식으로 변환
  * 리스트로
    * `list()` 타입변환 사용
* 튜플에서
  * dictionary로
    * `dict()` 타입변환 사용

***`.items()`메소드의 호출 결과로 반환되는 `view object` 는 사전의 내용이 바뀌면 그 영향을 받게 된다.***
* `view object`는 
  * 사전의 항목의 개수를 알 수 있다.
  * iter 함수를 이용하여 사전의 항목에 대한 반복자를 얻을 수 있다. 

## 7장

* key 는 hashable 객체, 변경 불가여야 한다.
* set 의 항목은 hashable 객체, 변경 불가여야 한다.
* set 타입 객체로 집합을 표현하여 연산 수행
    ```python
    >>> A = {1,2,3,4,5}
    >>> B = {4,5,6,7,8,9}
    >>> A|B             # 합집합
    {1,2,3,4,5,6,7,8,9}
    >>> A&B             # 교집합
    {4,5}
    >>> A-B             # 차집합
    {1,2,3}
    >>> B-A             # 차집합
    {8,9,6,7}
    >>> A^B             # 교집합의 여집합
    {1,2,3,6,7,8,9}
    ```
* set 항목 추가
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.add(7)             # add() method    
    >>> A.add(6)
    >>> A.union([44,55,99])  # union() method 
    ```
  * union method 는 iterable 객체를 인수로 받는다. (반복가능한 객체)
* 항목삭제
  * del Operator(연산자) 불가
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.remove(4)
    >>> print(A)
    {1,2,3,5}
    >>> A.remove(4)
    Traceback (~!@~!~@) # 오류 발생!!!!!!!!!!
    ```
    * remove(object) method는 object(객체)와 동일한 값을 지닌 항목을 삭제
    * 만약에 없으면 오류 발생
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.discard(4)
    >>> print(A)
    {1,2,3,5}
    >>> A.discard(4)
    {1,2,3,5}           # 아무일도 일어나지 않는다.
    ```
    * discard(object) method 는 없어도 아무런 오류가 발생하지 않는다.
  * 이렇게 두개다 다른 이유는 오류를 발생해서 수행동작을 가시적으로 만들 필요가 있기 때문\
* 항목존재
    ```python
    >>> 1 in {1,2,3,4}
    True
    >>> 5 in {1,2,3,4}
    False
    ```
* set을 list로
  * `sorted(A)`
    * sorted 함수는 iteravle 객체를 정렬하여 리스트로 반환
  * 직접타입변환
    * `set(A)`을 `list(A)` 로 바꾸고
    * 그걸 `A.sort()` 정렬하는 방법
  * 속도는 둘다 비스므리
* list를 set으로
  * 직접타입변환
    * `set()`으로 변환하면 순서가 바뀔 수 있다는 것을 명시
    * `list(A)`를 `set(A)`으로
      * 이러면 중복사라지고(set이니까)
    * 그걸 다시 `list(A)`로
    * 그 리스트를 다시 `A.sort()`
* `None` 
  * `[]` 빈 list
  * `{}` 빈 dictionary
  * 둘다 타입이 달라 비었어도 같지 않다. 그럴땐 `None`으로!
  * 어떤 의미 있는 행동을 하는 객체라기보다는 일종의 약속
    * 값이 없다는 약속
    * C 의 `null`

## 8장 제어문

### 조건문
* C conditional expression (조건 표현식)
  * `x > y ? x: y;`
  * x > y 조건에 따라 참이면 x 아니면 y
* python conditional expression
  * `A if statement else B`
  * if statement 가 참이면 A 아니면 B
* 중첩된 조건표현식
  * `A if statement else (B if statement else C)` 이런 식으로 하나 더 들어가는.
    * `A if statement else B if statement else C`
  ```python
  button = 2
  print("button1") if button == 1 else print("button2") if button == 2 else print("other button")
  button2
  ```
### for

* `for i in [0,1,2,3,4,5,6,7,8,9]:`
* `for i in range(0,10):`
* `for i in "python":`
* `for i in ('a', 'b', 'c', 1, 2, 3):`
* `for i in my_dict:` # 딕셔너리에서 키만나오고
* `for i in my_dict.values():`  # 이렇게 하면 values
* `for i in my_dict.items():`  # 이건 리스트 형식으로 둘 다 나오는

#### list comprehension 리스트 내포

리스트를 생성하는 새로운 문법

* `[expr for x in 반복가능객체]`
  * `[x for x in range(1, 10)]`

#### 리스트 내포 확장

리스트 내포에 if 추가

* `[expr (for x in 반복가능객체 if 조건식) (for x in 반복가능객체 if 조건식)]` 이렇게 이어서
  * `[expr for x in 반복가능객체 if 조건식 for x in 반복가능객체 if 조건식]`  
  * `[(x, y) for x in range(1, 10) for y in range(1, 10)]`
  * `(x, y)` 이건 표현식으로 튜플 타입 항목 표현

#### 중첩 리스트 내포

* `[expr for x in 반복가능객체 if 조건식]`
  * `[x for x in range(1, 10) if x%2==0]`
  * `['짝' if x%2==0 else '홀' for x in info]`

### while

* iterable 객체 필요
* 반복자 `iter()`함수로 `list()`를 iterable 객체로 만들면 while 도 반복 가능 
  * 내부 메쏘드 `__next__()` 사용
  ```python
  my_list=[1,2,3,4,5]
  it = iter(my_list)
  while it:
      print(it.__next__())
  ```
* 요 위 코드를 보면 for 문은 반복 가능한 객체에 특화된 형태의 제어문

### 기타문법

리스트 내포 처럼, 셋내포 튜플내포 만들기

  ```python
  set_comp = {x for x in range(1, 10)}
  {1.2.3.4.5.6.7.8.9}

  dict_comp = {x: x**2 for x in range(1, 10)}
  {1:1, 2:4, 3:9, 4:16, 5:25, 6:36, 7:49, 8:64, 9:81}
  
  tuple_comp = (x for x in range(1,10))
  <generator object> ~~   # 제네레이터 객체 생성
  ```

## 9장 함수