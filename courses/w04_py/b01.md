
Python책은 처음 가져본다(내가 산건 아니지만) 온라인으로, 오픈소스로, 무료pdf 서적으로 보고 혼자 스스로 공부하고 코드를 뜯어보면서 공부했었는데 커리큘럼 상에 있는 단 4일짜리 파이썬 교육에 책도 파이썬도 다시 곱씹게 되었다. 전반적으로 강사님도 내 스타일이 아니고(분명 좋으신분) 책은 더더욱 아니지만 나는 파이썬이 그나마 익숙(?) 하니 그럴지도..

언젠가 내가 파이썬을 유트브에 강의를 하게 되면 어떻게 할까를 많이 생각해 봤는데 그 첫 단락이 `왜 파이썬인가?` 였다. 근데 이번 강사님은 그게 전혀 없이 그냥 C와 C++을 비교한 수업을 진행하셨다. 물론 임베디드니 그럴 수 있지만 반대로 생각해보면 임베디드에서 파이썬을 배울 필요가 없는 것이 아닐까? `왜 파이썬인가?` 아니 `왜 임베디드에서도 파이썬인가?` 로 다시금 여쭤보고 싶다.

# 책 정리

아래 내용은 책을 보면서 이것 만큼은 꼭 까먹지 말자 느낌으로 가볍게 옮겼다.

## 2장

* 리터럴 
  * 3, 3.14, "I Love python"
  * 변하지 않고 고정된 데이터 자체의 표현

## 3장

* C 정적 타이핑
* Python 은 동적 타이핑
* Python 은 변수에 데이터를 대입하면 변수가 데이터를 직접 참조하는 것이 아니다.
* Python 은 모든 데이터가 파이썬이 제공하는 특수한 형태의 객체로 둘러쌓여 있다.
  * 그래서 타입 선언 불필요(이미 정해져 있으니까)

### 객체
* 객체 내부로 접근하기 위해서 이 객체를 참조하는 변수를 통해서 접근해야 한다.
    ```python
    >>> spell_object.print_spell()
    Hello World
    ```
* 어트리뷰트(속성)과 메쏘드
  * 위에서 객체 내부의 데이터를 담은 변수 `spell_object` 가 객체
  * `spell = "Hello World"` 는 `Atribute` 속성
  * `print_spell()` 그 안에 있는 함수는 `메쏘드`
  * `.` 은 속성접근자

## 4장

* 4 built-in data type
  * number type
  * sequences type
  * set type
  * mappings type
* `is 연산` 과 `== 연산`
  * -5~256 까지의 숫자는 한번만 생성
  * 그 외의 숫자는 생성될 때마다 새롭게 생성
  * is는 id 값을 비교하는 연산
  * == 내부 값을 비교하는 연산
* *사칙연산시 낮은 자료형은 승격*
* 쉬프트연산 ***8421코드***

## 5장 

* 깊은 복사를 하는 이유는 동일한 데이터를 가진 객체를 새롭게 생성하기 위한 것
* 리스트`[]`와 튜플`()`
  * 튜플의 메모리가 더 적게 소모된다
  * 튜플은 수정이 불가하기 때문에 안정, 보안의 목적으로 사용된다.
    ```python
    >>>'python' in s
    false
    ```
* `eval()` 문자열 연산처리
* `capitalize()` 첫문자 대문자
* `casefold()` 소문자, 문자열비교
* `insert(index, object)`
* `pop()` 내용 지우면서 출력
* `deepcopy()`
* `copy()`
* 튜플
  * `mytuple=()`    # 이렇게 하면 연산자
  * `mytuple=(1,)`  # 이렇게 해야 튜플 가능
  * `from collections import namedtuple`

## 6장

* 4 built-in data type
  * mappings type

Dictionary

* update
* setdefault
* key 존재 여부 확인
    ```python
        dict_test = {'first':7, 'second':77, 'third':777}
        x = {'first':0, 'end':100}      # 추가하려는 사전

        for my_key in x:
            if my_key not in dict_test:
                dict_test.update({my_key:x[my_key]})
    ```
* 항목삭제 
  * list나 dict 은 del 연산자 사용    

## 7장

* key 는 hashable 객체, 변경 불가여야 한다.
* set 의 항목은 hashable 객체, 변경 불가여야 한다.
* set 타입 객체로 집합을 표현하여 연산 수행
    ```python
    >>> A = {1,2,3,4,5}
    >>> B = {4,5,6,7,8,9}
    >>> A|B             # 합집합
    {1,2,3,4,5,6,7,8,9}
    >>> A&B             # 교집합
    {4,5}
    >>> A-B             # 차집합
    {1,2,3}
    >>> B-A             # 차집합
    {8,9,6,7}
    >>> A^B             # 교집합의 여집합
    {1,2,3,6,7,8,9}
    ```
* set 항목 추가
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.add(7)             # add() method    
    >>> A.add(6)
    >>> A.union([44,55,99])  # union() method 
    ```
  * union method 는 iterable 객체를 인수로 받는다. (반복가능한 객체)
* 항목삭제
  * del Operator(연산자) 불가
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.remove(4)
    >>> print(A)
    {1,2,3,5}
    >>> A.remove(4)
    Traceback (~!@~!~@) # 오류 발생!!!!!!!!!!
    ```
    * remove(object) method는 object(객체)와 동일한 값을 지닌 항목을 삭제
    * 만약에 없으면 오류 발생
    ```python
    >>> A = {1,2,3,4,5}
    >>> A.discard(4)
    >>> print(A)
    {1,2,3,5}
    >>> A.discard(4)
    {1,2,3,5}           # 아무일도 일어나지 않는다.
    ```
    * discard(object) method 는 없어도 아무런 오류가 발생하지 않는다.
  * 이렇게 두개다 다른 이유는 오류를 발생해서 수행동작을 가시적으로 만들 필요가 있기 때문\
* 항목존재
    ```python
    >>> 1 in {1,2,3,4}
    True
    >>> 5 in {1,2,3,4}
    False
    ```
* set을 list로
  * `sorted(A)`
    * sorted 함수는 iteravle 객체를 정렬하여 리스트로 반환
  * 직접타입변환
    * `set(A)`을 `list(A)` 로 바꾸고
    * 그걸 `A.sort()` 정렬하는 방법
  * 속도는 둘다 비스므리
* list를 set으로
  * 직접타입변환
    * `set()`으로 변환하면 순서가 바뀔 수 있다는 것을 명시
    * `list(A)`를 `set(A)`으로
      * 이러면 중복사라지고(set이니까)
    * 그걸 다시 `list(A)`로
    * 그 리스트를 다시 `A.sort()`
* `None` 
  * `[]` 빈 list
  * `{}` 빈 dictionary
  * 둘다 타입이 달라 비었어도 같지 않다. 그럴땐 `None`으로!
  * 어떤 의미 있는 행동을 하는 객체라기보다는 일종의 약속
    * 값이 없다는 약속
    * C 의 `null`

## 8장 제어문